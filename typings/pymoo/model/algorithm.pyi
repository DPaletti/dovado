"""
This type stub file was generated by pyright.
"""

class Algorithm:
    """

    This class represents the abstract class for any algorithm to be implemented. Most importantly it
    provides the solve method that is used to optimize a given problem.

    The solve method provides a wrapper function which does validate the input.


    Parameters
    ----------

    problem : :class:`~pymoo.model.problem.Problem`
        Problem to be solved by the algorithm

    termination: :class:`~pymoo.model.termination.Termination`
        Object that tells the algorithm when to terminate.

    seed : int
        Random seed to be used. Same seed is supposed to return the same result. If set to None, a random seed
        is chosen randomly and stored in the result object to ensure reproducibility.

    verbose : bool
        If true information during the algorithm execution are displayed

    callback : func
        A callback function can be passed that is executed every generation. The parameters for the function
        are the algorithm itself, the number of evaluations so far and the current population.

            def callback(algorithm):
                pass

    save_history : bool
        If true, a current snapshot of each generation is saved.

    pf : numpy.array
        The Pareto-front for the given problem. If provided performance metrics are printed during execution.

    return_least_infeasible : bool
        Whether the algorithm should return the least infeasible solution, if no solution was found.

    evaluator : :class:`~pymoo.model.evaluator.Evaluator`
        The evaluator which can be used to make modifications before calling the evaluate function of a problem.


    """
    def __init__(self, **kwargs) -> None:
        ...
    
    def setup(self, problem, termination=..., callback=..., display=..., seed=..., verbose=..., save_history=..., return_least_infeasible=..., pf=..., evaluator=..., **kwargs):
        ...
    
    def initialize(self):
        ...
    
    def solve(self):
        ...
    
    def has_next(self):
        ...
    
    def next(self):
        ...
    
    def finalize(self):
        ...
    
    def result(self):
        ...
    


def filter_optimum(pop, least_infeasible=...):
    ...

