"""
This type stub file was generated by pyright.
"""

class Problem:
    """
    Superclass for each problem that is defined. It provides attributes such
    as the number of variables, number of objectives or constraints.
    Also, the lower and upper bounds are stored. If available the Pareto-front, nadir point
    and ideal point are stored.

    """
    def __init__(self, n_var=..., n_obj=..., n_constr=..., xl=..., xu=..., type_var=..., evaluation_of=..., replace_nan_values_of=..., parallelization=..., elementwise_evaluation=..., exclude_from_serialization=..., callback=...) -> None:
        """

        Parameters
        ----------
        n_var : int
            number of variables
        n_obj : int
            number of objectives
        n_constr : int
            number of constraints
        xl : np.array or int
            lower bounds for the variables. if integer all lower bounds are equal.
        xu : np.array or int
            upper bounds for the variable. if integer all upper bounds are equal.
        type_var : numpy type
            type of the variable to be evaluated. Can also be np.object if it is a complex data type
        elementwise_evaluation : bool

        parallelization : str or tuple
            See :ref:`nb_parallelization` for guidance on parallelization.

        """
        ...
    
    def nadir_point(self):
        """
        Returns
        -------
        nadir_point : np.array
            The nadir point for a multi-objective problem.
            If single-objective, it returns the best possible solution which is equal to the ideal point.

        """
        ...
    
    def ideal_point(self):
        """
        Returns
        -------
        ideal_point : np.array
            The ideal point for a multi-objective problem. If single-objective
            it returns the best possible solution.
        """
        ...
    
    def pareto_front(self, *args, use_cache=..., exception_if_failing=..., **kwargs):
        """
        Parameters
        ----------

        args : Same problem implementation need some more information to create the Pareto front. For instance
                the DTLZ problem suite generates the Pareto front by usage of the reference directions.
                We refer to the corresponding problem for more information.
        exception_if_failing : bool
                Whether to throw an exception when generating the Pareto front has failed.
        use_cache : bool
                Whether to use the cache if the Pareto front has been generated beforehand.

        Returns
        -------
        P : np.array
            The Pareto front of a given problem. It is only loaded or calculate the first time and then cached.
            For a single-objective problem only one point is returned but still in a two dimensional array.

        """
        ...
    
    def pareto_set(self, *args, use_cache=..., **kwargs):
        """
        Returns
        -------
        S : np.array
            Returns the pareto set for a problem. Points in the X space to be known to be optimal!
        """
        ...
    
    def evaluate(self, X, *args, return_values_of=..., return_as_dictionary=..., **kwargs):
        """
        Evaluate the given problem.

        The function values set as defined in the function.
        The constraint values are meant to be positive if infeasible. A higher positive values means "more" infeasible".
        If they are 0 or negative, they will be considered as feasible what ever their value is.

        Parameters
        ----------

        X : np.array
            A two dimensional matrix where each row is a point to evaluate and each column a variable.

        return_as_dictionary : bool
            If this is true than only one object, a dictionary, is returned. This contains all the results
            that are defined by return_values_of. Otherwise, by default a tuple as defined is returned.

        return_values_of : list of strings
            You can provide a list of strings which defines the values that are returned. By default it is set to
            "auto" which means depending on the problem the function values or additional the constraint violation (if
            the problem has constraints) are returned. Otherwise, you can provide a list of values to be returned.

            Allowed is ["F", "CV", "G", "dF", "dG", "dCV", "feasible"] where the d stands for
            derivative and h stands for hessian matrix.


        Returns
        -------

            A dictionary, if return_as_dictionary enabled, or a list of values as defined in return_values_of.

        """
        ...
    
    def has_bounds(self):
        ...
    
    def has_constraints(self):
        ...
    
    def bounds(self):
        ...
    
    def name(self):
        """
        Returns
        -------
        name : str
            The name of the problem. Per default it is the name of the class but it can be overridden.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    @staticmethod
    def calc_constraint_violation(G):
        ...
    
    def __getstate__(self):
        ...
    
    def set_boundaries_as_constraints(self, val=...):
        ...
    


def at_least2d(d):
    ...

def evaluate_in_parallel(_x, calc_gradient, func, args, kwargs):
    ...

def evaluate_in_parallel_object(_x, calc_gradient, obj, args, kwargs):
    ...

def func_return_none(*args, **kwargs):
    ...

class FunctionalProblem(Problem):
    def __init__(self, n_var, objs, constr_ieq=..., constr_eq=..., constr_eq_eps=..., func_pf=..., func_ps=..., **kwargs) -> None:
        ...
    


class MetaProblem(Problem):
    def __init__(self, problem) -> None:
        ...
    
    def pareto_front(self, *args, **kwargs):
        ...
    
    def pareto_set(self, *args, **kwargs):
        ...
    


class ConstraintsAsPenaltyProblem(MetaProblem):
    def __init__(self, problem, penalty=...) -> None:
        ...
    
    def pareto_front(self, *args, **kwargs):
        ...
    
    def pareto_set(self, *args, **kwargs):
        ...
    


class StaticProblem(MetaProblem):
    def __init__(self, problem, **kwargs) -> None:
        ...
    


