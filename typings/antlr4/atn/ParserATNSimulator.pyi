"""
This type stub file was generated by pyright.
"""

from antlr4 import DFA
from antlr4.PredictionContext import PredictionContextCache
from antlr4.BufferedTokenStream import TokenStream
from antlr4.Parser import Parser
from antlr4.ParserRuleContext import ParserRuleContext
from antlr4.RuleContext import RuleContext
from antlr4.atn.ATN import ATN
from antlr4.atn.ATNConfig import ATNConfig
from antlr4.atn.ATNConfigSet import ATNConfigSet
from antlr4.atn.ATNSimulator import ATNSimulator
from antlr4.atn.ATNState import ATNState, DecisionState
from antlr4.atn.Transition import ActionTransition, PrecedencePredicateTransition, PredicateTransition, RuleTransition, Transition
from antlr4.dfa.DFAState import DFAState
from antlr4.error.Errors import NoViableAltException

class ParserATNSimulator(ATNSimulator):
    debug = ...
    debug_list_atn_decisions = ...
    dfa_debug = ...
    retry_debug = ...
    def __init__(self, parser: Parser, atn: ATN, decisionToDFA: list, sharedContextCache: PredictionContextCache) -> None:
        ...
    
    def reset(self):
        ...
    
    def adaptivePredict(self, input: TokenStream, decision: int, outerContext: ParserRuleContext):
        ...
    
    def execATN(self, dfa: DFA, s0: DFAState, input: TokenStream, startIndex: int, outerContext: ParserRuleContext):
        ...
    
    def getExistingTargetState(self, previousD: DFAState, t: int):
        ...
    
    def computeTargetState(self, dfa: DFA, previousD: DFAState, t: int):
        ...
    
    def predicateDFAState(self, dfaState: DFAState, decisionState: DecisionState):
        ...
    
    def execATNWithFullContext(self, dfa: DFA, D: DFAState, s0: ATNConfigSet, input: TokenStream, startIndex: int, outerContext: ParserRuleContext):
        ...
    
    def computeReachSet(self, closure: ATNConfigSet, t: int, fullCtx: bool):
        ...
    
    def removeAllConfigsNotInRuleStopState(self, configs: ATNConfigSet, lookToEndOfRule: bool):
        ...
    
    def computeStartState(self, p: ATNState, ctx: RuleContext, fullCtx: bool):
        ...
    
    def applyPrecedenceFilter(self, configs: ATNConfigSet):
        ...
    
    def getReachableTarget(self, trans: Transition, ttype: int):
        ...
    
    def getPredsForAmbigAlts(self, ambigAlts: set, configs: ATNConfigSet, nalts: int):
        ...
    
    def getPredicatePredictions(self, ambigAlts: set, altToPred: list):
        ...
    
    def getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(self, configs: ATNConfigSet, outerContext: ParserRuleContext):
        ...
    
    def getAltThatFinishedDecisionEntryRule(self, configs: ATNConfigSet):
        ...
    
    def splitAccordingToSemanticValidity(self, configs: ATNConfigSet, outerContext: ParserRuleContext):
        ...
    
    def evalSemanticContext(self, predPredictions: list, outerContext: ParserRuleContext, complete: bool):
        ...
    
    def closure(self, config: ATNConfig, configs: ATNConfigSet, closureBusy: set, collectPredicates: bool, fullCtx: bool, treatEofAsEpsilon: bool):
        ...
    
    def closureCheckingStopState(self, config: ATNConfig, configs: ATNConfigSet, closureBusy: set, collectPredicates: bool, fullCtx: bool, depth: int, treatEofAsEpsilon: bool):
        ...
    
    def closure_(self, config: ATNConfig, configs: ATNConfigSet, closureBusy: set, collectPredicates: bool, fullCtx: bool, depth: int, treatEofAsEpsilon: bool):
        ...
    
    def canDropLoopEntryEdgeInLeftRecursiveRule(self, config):
        ...
    
    def getRuleName(self, index: int):
        ...
    
    epsilonTargetMethods = ...
    def getEpsilonTarget(self, config: ATNConfig, t: Transition, collectPredicates: bool, inContext: bool, fullCtx: bool, treatEofAsEpsilon: bool):
        ...
    
    def actionTransition(self, config: ATNConfig, t: ActionTransition):
        ...
    
    def precedenceTransition(self, config: ATNConfig, pt: PrecedencePredicateTransition, collectPredicates: bool, inContext: bool, fullCtx: bool):
        ...
    
    def predTransition(self, config: ATNConfig, pt: PredicateTransition, collectPredicates: bool, inContext: bool, fullCtx: bool):
        ...
    
    def ruleTransition(self, config: ATNConfig, t: RuleTransition):
        ...
    
    def getConflictingAlts(self, configs: ATNConfigSet):
        ...
    
    def getConflictingAltsOrUniqueAlt(self, configs: ATNConfigSet):
        ...
    
    def getTokenName(self, t: int):
        ...
    
    def getLookaheadName(self, input: TokenStream):
        ...
    
    def dumpDeadEndConfigs(self, nvae: NoViableAltException):
        ...
    
    def noViableAlt(self, input: TokenStream, outerContext: ParserRuleContext, configs: ATNConfigSet, startIndex: int):
        ...
    
    def getUniqueAlt(self, configs: ATNConfigSet):
        ...
    
    def addDFAEdge(self, dfa: DFA, from_: DFAState, t: int, to: DFAState):
        ...
    
    def addDFAState(self, dfa: DFA, D: DFAState):
        ...
    
    def reportAttemptingFullContext(self, dfa: DFA, conflictingAlts: set, configs: ATNConfigSet, startIndex: int, stopIndex: int):
        ...
    
    def reportContextSensitivity(self, dfa: DFA, prediction: int, configs: ATNConfigSet, startIndex: int, stopIndex: int):
        ...
    
    def reportAmbiguity(self, dfa: DFA, D: DFAState, startIndex: int, stopIndex: int, exact: bool, ambigAlts: set, configs: ATNConfigSet):
        ...
    


